{\rtf1\ansi\ansicpg1250\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red155\green35\blue147;\red255\green255\blue255;\red0\green0\blue0;
\red15\green104\blue160;\red57\green0\blue160;\red108\green54\blue169;\red196\green26\blue22;\red28\green0\blue207;
}
{\*\expandedcolortbl;;\csgenericrgb\c60759\c13753\c57628;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c0\c0\c0\c85000;
\csgenericrgb\c5882\c40784\c62745;\csgenericrgb\c22454\c0\c62803;\csgenericrgb\c42190\c21278\c66379;\csgenericrgb\c77000\c10200\c8600;\csgenericrgb\c11000\c0\c81000;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab593
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0\b\fs24 \cf2 \cb3 func
\f1\b0 \cf4  \cf5 hostCPULoadInfo\cf4 () -> \cf6 host_cpu_load_info\cf4 ? \{\
        
\f0\b \cf2 let
\f1\b0 \cf4  HOST_CPU_LOAD_INFO_COUNT = \cf6 MemoryLayout\cf4 <\cf6 host_cpu_load_info\cf4 >.\cf7 stride/\cf6 MemoryLayout\cf4 <\cf6 integer_t\cf4 >.\cf7 stride\cf4 \
        
\f0\b \cf2 var
\f1\b0 \cf4  size = \cf6 mach_msg_type_number_t\cf4 (HOST_CPU_LOAD_INFO_COUNT)\
        
\f0\b \cf2 var
\f1\b0 \cf4  cpuLoadInfo = \cf6 host_cpu_load_info\cf4 ()\
        \
        
\f0\b \cf2 let
\f1\b0 \cf4  result = \cf7 withUnsafeMutablePointer\cf4 (to: &cpuLoadInfo) \{\
            $0.\cf7 withMemoryRebound\cf4 (to: \cf6 integer_t\cf4 .
\f0\b \cf2 self
\f1\b0 \cf4 , capacity: HOST_CPU_LOAD_INFO_COUNT) \{\
                \cf7 host_statistics\cf4 (\cf7 mach_host_self\cf4 (), \cf7 HOST_CPU_LOAD_INFO\cf4 , $0, &size)\
            \}\
        \}\
        
\f0\b \cf2 if
\f1\b0 \cf4  result \cf7 !=\cf4  \cf7 KERN_SUCCESS\cf4 \{\
            \cf7 print\cf4 (\cf8 "Error  - \cf4 \\(
\f0\b \cf2 #file
\f1\b0 \cf4 )\cf8 : \cf4 \\(
\f0\b \cf2 #function
\f1\b0 \cf4 )\cf8  - kern_result_t = \cf4 \\(result)\cf8 "\cf4 )\
            
\f0\b \cf2 return
\f1\b0 \cf4  
\f0\b \cf2 nil
\f1\b0 \cf4 \
        \}\
        
\f0\b \cf2 return
\f1\b0 \cf4  cpuLoadInfo\
    \}\
    
\f0\b \cf2 func
\f1\b0 \cf4  \cf5 getCPULoadInfo\cf4 ()-> \cf6 String\cf4 \{\
        
\f0\b \cf2 var
\f1\b0 \cf4  cpuUsageInfo = \cf8 ""\cf4 \
        
\f0\b \cf2 var
\f1\b0 \cf4  cpuInfo: \cf6 processor_info_array_t\cf4 !\
        
\f0\b \cf2 var
\f1\b0 \cf4  prevCpuInfo: \cf6 processor_info_array_t\cf4 ?\
        
\f0\b \cf2 var
\f1\b0 \cf4  numCpuInfo: \cf6 mach_msg_type_number_t\cf4  = \cf9 0\cf4 \
        
\f0\b \cf2 var
\f1\b0 \cf4  numPrevCpuInfo: \cf6 mach_msg_type_number_t\cf4  = \cf9 0\cf4 \
        
\f0\b \cf2 var
\f1\b0 \cf4  numCPUs: \cf6 uint\cf4  = \cf9 0\cf4 \
        
\f0\b \cf2 let
\f1\b0 \cf4  CPUUsageLock: \cf6 NSLock\cf4  = \cf6 NSLock\cf4 ()\
        
\f0\b \cf2 var
\f1\b0 \cf4  usage:\cf6 Float32\cf4  = \cf9 0\cf4 \
        \
        
\f0\b \cf2 let
\f1\b0 \cf4  mibKeys: [\cf6 Int32\cf4 ] = [ \cf7 CTL_HW\cf4 , \cf7 HW_NCPU\cf4  ]\
        mibKeys.\cf7 withUnsafeBufferPointer\cf4 () \{ mib 
\f0\b \cf2 in
\f1\b0 \cf4 \
            
\f0\b \cf2 var
\f1\b0 \cf4  sizeOfNumCPUs: \cf6 size_t\cf4  = \cf6 MemoryLayout\cf4 <\cf6 uint\cf4 >.\cf7 size\cf4 \
            
\f0\b \cf2 let
\f1\b0 \cf4  status = \cf7 sysctl\cf4 (\cf6 processor_info_array_t\cf4 (mutating: mib.\cf7 baseAddress\cf4 ), \cf9 2\cf4 , &numCPUs, &sizeOfNumCPUs, 
\f0\b \cf2 nil
\f1\b0 \cf4 , \cf9 0\cf4 )\
            
\f0\b \cf2 if
\f1\b0 \cf4  status \cf7 !=\cf4  \cf9 0\cf4  \{\
                numCPUs = \cf9 1\cf4 \
            \}\
        \}\
        \
        
\f0\b \cf2 var
\f1\b0 \cf4  numCPUsU: \cf6 natural_t\cf4  = \cf9 0\cf4 \
        
\f0\b \cf2 let
\f1\b0 \cf4  err: \cf6 kern_return_t\cf4  = \cf7 host_processor_info\cf4 (\cf7 mach_host_self\cf4 (), \cf7 PROCESSOR_CPU_LOAD_INFO\cf4 , &numCPUsU, &cpuInfo, &numCpuInfo);\
        
\f0\b \cf2 if
\f1\b0 \cf4  err \cf7 ==\cf4  \cf7 KERN_SUCCESS\cf4  \{\
            CPUUsageLock.\cf7 lock\cf4 ()\
            \
            
\f0\b \cf2 for
\f1\b0 \cf4  i 
\f0\b \cf2 in
\f1\b0 \cf4  \cf9 0\cf4  \cf7 ..<\cf4  \cf6 Int32\cf4 (numCPUs) \{\
                
\f0\b \cf2 var
\f1\b0 \cf4  inUse: \cf6 Int32\cf4 \
                
\f0\b \cf2 var
\f1\b0 \cf4  total: \cf6 Int32\cf4 \
                
\f0\b \cf2 if
\f1\b0 \cf4  
\f0\b \cf2 let
\f1\b0 \cf4  prevCpuInfo = prevCpuInfo \{\
                    inUse = cpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_USER\cf4 )]\
                        \cf7 -\cf4  prevCpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_USER\cf4 )]\
                        \cf7 +\cf4  cpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_SYSTEM\cf4 )]\
                        \cf7 -\cf4  prevCpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_SYSTEM\cf4 )]\
                        \cf7 +\cf4  cpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_NICE\cf4 )]\
                        \cf7 -\cf4  prevCpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_NICE\cf4 )]\
                    total = inUse \cf7 +\cf4  (cpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_IDLE\cf4 )]\
                        \cf7 -\cf4  prevCpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_IDLE\cf4 )])\
                \} 
\f0\b \cf2 else
\f1\b0 \cf4  \{\
                    inUse = cpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_USER\cf4 )]\
                        \cf7 +\cf4  cpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_SYSTEM\cf4 )]\
                        \cf7 +\cf4  cpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_NICE\cf4 )]\
                    total = inUse \cf7 +\cf4  cpuInfo[\cf6 Int\cf4 (\cf7 CPU_STATE_MAX\cf4  \cf7 *\cf4  i \cf7 +\cf4  \cf7 CPU_STATE_IDLE\cf4 )]\
                \}\
                
\f0\b \cf2 let
\f1\b0 \cf4  coreInfo = \cf6 Float\cf4 (inUse) \cf7 /\cf4  \cf6 Float\cf4 (total)\
                usage \cf7 +=\cf4  coreInfo\
                \cf7 print\cf4 (\cf6 String\cf4 (format: \cf8 "Core: %u Usage: %f"\cf4 , i, \cf6 Float\cf4 (inUse) \cf7 /\cf4  \cf6 Float\cf4 (total)))\
            \}\
            cpuUsageInfo = \cf6 String\cf4 (format:\cf8 "%.2f"\cf4 ,\cf9 100\cf4  \cf7 *\cf4  \cf6 Float\cf4 (usage) \cf7 /\cf4  \cf6 Float\cf4 (numCPUs))\
            CPUUsageLock.\cf7 unlock\cf4 ()\
            \
            
\f0\b \cf2 if
\f1\b0 \cf4  
\f0\b \cf2 let
\f1\b0 \cf4  prevCpuInfo = prevCpuInfo \{\
                
\f0\b \cf2 let
\f1\b0 \cf4  prevCpuInfoSize: \cf6 size_t\cf4  = \cf6 MemoryLayout\cf4 <\cf6 integer_t\cf4 >.\cf7 stride\cf4  \cf7 *\cf4  \cf6 Int\cf4 (numPrevCpuInfo)\
                \cf7 vm_deallocate\cf4 (\cf7 mach_task_self_\cf4 , \cf6 vm_address_t\cf4 (bitPattern: prevCpuInfo), \cf6 vm_size_t\cf4 (prevCpuInfoSize))\
            \}\
            \
            prevCpuInfo = cpuInfo\
            numPrevCpuInfo = numCpuInfo\
            \
            cpuInfo = 
\f0\b \cf2 nil
\f1\b0 \cf4 \
            numCpuInfo = \cf9 0\cf4 \
        \} 
\f0\b \cf2 else
\f1\b0 \cf4  \{\
            \cf7 print\cf4 (\cf8 "Error!"\cf4 )\
        \}\
        \
        
\f0\b \cf2 return
\f1\b0 \cf4  cpuUsageInfo\
    \}}
